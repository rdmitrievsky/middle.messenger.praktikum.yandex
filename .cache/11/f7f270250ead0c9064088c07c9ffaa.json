{"id":"core/Block.ts","dependencies":[{"name":"C:\\WebDesign\\Projects\\middle.messenger.praktikum.yandex\\tsconfig.json","includedInParent":true,"mtime":1649621347494},{"name":"C:\\WebDesign\\Projects\\middle.messenger.praktikum.yandex\\package.json","includedInParent":true,"mtime":1649623278963},{"name":"./EventBus","loc":{"line":6,"column":43,"index":264},"parent":"C:\\WebDesign\\Projects\\middle.messenger.praktikum.yandex\\src\\core\\Block.ts","resolved":"C:\\WebDesign\\Projects\\middle.messenger.praktikum.yandex\\src\\core\\EventBus.ts"},{"name":"nanoid","loc":{"line":7,"column":25,"index":306},"parent":"C:\\WebDesign\\Projects\\middle.messenger.praktikum.yandex\\src\\core\\Block.ts","resolved":"C:\\WebDesign\\Projects\\middle.messenger.praktikum.yandex\\node_modules\\nanoid\\index.browser.js"},{"name":"handlebars","loc":{"line":8,"column":45,"index":363},"parent":"C:\\WebDesign\\Projects\\middle.messenger.praktikum.yandex\\src\\core\\Block.ts","resolved":"C:\\WebDesign\\Projects\\middle.messenger.praktikum.yandex\\node_modules\\handlebars\\lib\\index.js"}],"generated":{"js":"\"use strict\";\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar EventBus_1 = __importDefault(require(\"./EventBus\"));\n\nvar nanoid_1 = require(\"nanoid\");\n\nvar handlebars_1 = __importDefault(require(\"handlebars\"));\n\nvar Block = /*#__PURE__*/function () {\n  function Block(props) {\n    var _this = this;\n\n    _classCallCheck(this, Block);\n\n    this.id = (0, nanoid_1.nanoid)(6);\n    this._element = null;\n    this.children = {};\n    this.state = {};\n    this.refs = {};\n\n    this.setProps = function (nextProps) {\n      if (!nextProps) {\n        return;\n      }\n\n      Object.assign(_this.props, nextProps);\n    };\n\n    this.setState = function (nextState) {\n      if (!nextState) {\n        return;\n      }\n\n      Object.assign(_this.state, nextState);\n    };\n\n    var eventBus = new EventBus_1.default();\n    this._meta = {\n      props: props\n    };\n    this.getStateFromProps(props);\n    this.props = this._makePropsProxy(props || {});\n    this.state = this._makePropsProxy(this.state);\n\n    this.eventBus = function () {\n      return eventBus;\n    };\n\n    this._registerEvents(eventBus);\n\n    eventBus.emit(Block.EVENTS.INIT, this.props);\n  }\n\n  _createClass(Block, [{\n    key: \"_registerEvents\",\n    value: function _registerEvents(eventBus) {\n      eventBus.on(Block.EVENTS.INIT, this.init.bind(this));\n      eventBus.on(Block.EVENTS.FLOW_CDM, this._componentDidMount.bind(this));\n      eventBus.on(Block.EVENTS.FLOW_CDU, this._componentDidUpdate.bind(this));\n      eventBus.on(Block.EVENTS.FLOW_RENDER, this._render.bind(this));\n    }\n  }, {\n    key: \"_createResources\",\n    value: function _createResources() {\n      this._element = this._createDocumentElement('div');\n    }\n  }, {\n    key: \"getStateFromProps\",\n    value: function getStateFromProps(props) {\n      this.state = {};\n    }\n  }, {\n    key: \"init\",\n    value: function init() {\n      this._createResources();\n\n      this.eventBus().emit(Block.EVENTS.FLOW_RENDER, this.props);\n    }\n  }, {\n    key: \"_componentDidMount\",\n    value: function _componentDidMount(props) {\n      this.componentDidMount(props);\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount(props) {}\n  }, {\n    key: \"_componentDidUpdate\",\n    value: function _componentDidUpdate(oldProps, newProps) {\n      var response = this.componentDidUpdate(oldProps, newProps);\n\n      if (!response) {\n        return;\n      }\n\n      this._render();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(oldProps, newProps) {\n      return true;\n    }\n  }, {\n    key: \"element\",\n    get: function get() {\n      return this._element;\n    }\n  }, {\n    key: \"_render\",\n    value: function _render() {\n      var fragment = this._compile();\n\n      this._removeEvents();\n\n      var newElement = fragment.firstElementChild;\n\n      this._element.replaceWith(newElement);\n\n      this._element = newElement;\n\n      this._addEvents();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return '';\n    }\n  }, {\n    key: \"getContent\",\n    value: function getContent() {\n      var _this2 = this;\n\n      var _a, _b; // Хак, чтобы вызвать CDM только после добавления в DOM\n\n\n      if (((_b = (_a = this.element) === null || _a === void 0 ? void 0 : _a.parentNode) === null || _b === void 0 ? void 0 : _b.nodeType) === Node.DOCUMENT_FRAGMENT_NODE) {\n        setTimeout(function () {\n          var _a, _b;\n\n          if (((_b = (_a = _this2.element) === null || _a === void 0 ? void 0 : _a.parentNode) === null || _b === void 0 ? void 0 : _b.nodeType) !== Node.DOCUMENT_FRAGMENT_NODE) {\n            _this2.eventBus().emit(Block.EVENTS.FLOW_CDM);\n          }\n        }, 100);\n      }\n\n      return this.element;\n    }\n  }, {\n    key: \"_makePropsProxy\",\n    value: function _makePropsProxy(props) {\n      // Можно и так передать this\n      // Такой способ больше не применяется с приходом ES6+\n      var self = this;\n      return new Proxy(props, {\n        get: function get(target, prop) {\n          var value = target[prop];\n          return typeof value === 'function' ? value.bind(target) : value;\n        },\n        set: function set(target, prop, value) {\n          target[prop] = value; // Запускаем обновление компоненты\n          // Плохой cloneDeep, в след итерации нужно заставлять добавлять cloneDeep им самим\n\n          self.eventBus().emit(Block.EVENTS.FLOW_CDU, Object.assign({}, target), target);\n          return true;\n        },\n        deleteProperty: function deleteProperty() {\n          throw new Error('Нет доступа');\n        }\n      });\n    }\n  }, {\n    key: \"_createDocumentElement\",\n    value: function _createDocumentElement(tagName) {\n      return document.createElement(tagName);\n    }\n  }, {\n    key: \"_removeEvents\",\n    value: function _removeEvents() {\n      var _this3 = this;\n\n      var events = this.props.events;\n\n      if (!events || !this._element) {\n        return;\n      }\n\n      Object.entries(events).forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            event = _ref2[0],\n            listener = _ref2[1];\n\n        _this3._element.removeEventListener(event, listener);\n      });\n    }\n  }, {\n    key: \"_addEvents\",\n    value: function _addEvents() {\n      var _this4 = this;\n\n      var events = this.props.events;\n\n      if (!events) {\n        return;\n      }\n\n      Object.entries(events).forEach(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            event = _ref4[0],\n            listener = _ref4[1];\n\n        _this4._element.addEventListener(event, listener);\n      });\n    }\n  }, {\n    key: \"_compile\",\n    value: function _compile() {\n      var fragment = document.createElement('template');\n      /**\r\n       * Рендерим шаблон\r\n       */\n\n      var template = handlebars_1.default.compile(this.render());\n      fragment.innerHTML = template(Object.assign(Object.assign(Object.assign({}, this.state), this.props), {\n        children: this.children,\n        refs: this.refs\n      }));\n      /**\r\n       * Заменяем заглушки на компоненты\r\n       */\n\n      Object.entries(this.children).forEach(function (_ref5) {\n        var _ref6 = _slicedToArray(_ref5, 2),\n            id = _ref6[0],\n            component = _ref6[1];\n\n        /**\r\n         * Ищем заглушку по id\r\n         */\n        var stub = fragment.content.querySelector(\"[data-id=\\\"\".concat(id, \"\\\"]\"));\n\n        if (!stub) {\n          return;\n        }\n\n        var stubChilds = stub.childNodes.length ? stub.childNodes : [];\n        /**\r\n         * Заменяем заглушку на component._element\r\n         */\n\n        var content = component.getContent();\n        stub.replaceWith(content);\n        /**\r\n         * Ищем элемент layout-а, куда вставлять детей\r\n         */\n\n        var layoutContent = content.querySelector('[data-layout=\"1\"]');\n\n        if (layoutContent && stubChilds.length) {\n          layoutContent.append.apply(layoutContent, _toConsumableArray(stubChilds));\n        }\n      });\n      /**\r\n       * Возвращаем фрагмент\r\n       */\n\n      return fragment.content;\n    }\n  }, {\n    key: \"show\",\n    value: function show() {\n      this.getContent().style.display = 'block';\n    }\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      this.getContent().style.display = 'none';\n    }\n  }]);\n\n  return Block;\n}();\n\nexports.default = Block;\nBlock.EVENTS = {\n  INIT: 'init',\n  FLOW_CDM: 'flow:component-did-mount',\n  FLOW_CDU: 'flow:component-did-update',\n  FLOW_RENDER: 'flow:render'\n};"},"sourceMaps":null,"error":null,"hash":"96c83dfd2dd867a8db0d47e8dba5c739","cacheData":{"env":{}}}